/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "cosmwasm";
import { Uint128, Binary, AssetInfo, PairType, ExecuteOnReply } from "./AstroportGenerator.types";
export interface AstroportGeneratorMessage {
    contractAddress: string;
    sender: string;
    updateConfig: ({ checkpointGeneratorLimit, generatorController, guardian, vestingContract, votingEscrow, votingEscrowDelegation }: {
        checkpointGeneratorLimit?: number;
        generatorController?: string;
        guardian?: string;
        vestingContract?: string;
        votingEscrow?: string;
        votingEscrowDelegation?: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    setupPools: ({ pools }: {
        pools: string[][];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    updatePool: ({ hasAssetRewards, lpToken }: {
        hasAssetRewards: boolean;
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    claimRewards: ({ lpTokens }: {
        lpTokens: string[];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    withdraw: ({ amount, lpToken }: {
        amount: Uint128;
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    emergencyWithdraw: ({ lpToken }: {
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    sendOrphanProxyReward: ({ lpToken, recipient }: {
        lpToken: string;
        recipient: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    receive: ({ amount, msg, sender }: {
        amount: Uint128;
        msg: Binary;
        sender: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    setTokensPerBlock: ({ amount }: {
        amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    proposeNewOwner: ({ expiresIn, owner }: {
        expiresIn: number;
        owner: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    dropOwnershipProposal: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
    claimOwnership: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
    moveToProxy: ({ lpToken, proxy }: {
        lpToken: string;
        proxy: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    migrateProxy: ({ lpToken, newProxy }: {
        lpToken: string;
        newProxy: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    updateBlockedTokenslist: ({ add, remove }: {
        add?: AssetInfo[];
        remove?: AssetInfo[];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    deactivatePool: ({ lpToken }: {
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    deactivatePools: ({ pairTypes }: {
        pairTypes: PairType[];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    checkpointUserBoost: ({ generators, user }: {
        generators: string[];
        user?: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    callback: ({ action }: {
        action: ExecuteOnReply;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export declare class AstroportGeneratorMessageComposer implements AstroportGeneratorMessage {
    sender: string;
    contractAddress: string;
    constructor(sender: string, contractAddress: string);
    updateConfig: ({ checkpointGeneratorLimit, generatorController, guardian, vestingContract, votingEscrow, votingEscrowDelegation }: {
        checkpointGeneratorLimit?: number | undefined;
        generatorController?: string | undefined;
        guardian?: string | undefined;
        vestingContract?: string | undefined;
        votingEscrow?: string | undefined;
        votingEscrowDelegation?: string | undefined;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    setupPools: ({ pools }: {
        pools: string[][];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    updatePool: ({ hasAssetRewards, lpToken }: {
        hasAssetRewards: boolean;
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    claimRewards: ({ lpTokens }: {
        lpTokens: string[];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    withdraw: ({ amount, lpToken }: {
        amount: Uint128;
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    emergencyWithdraw: ({ lpToken }: {
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    sendOrphanProxyReward: ({ lpToken, recipient }: {
        lpToken: string;
        recipient: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    receive: ({ amount, msg, sender }: {
        amount: Uint128;
        msg: Binary;
        sender: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    setTokensPerBlock: ({ amount }: {
        amount: Uint128;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    proposeNewOwner: ({ expiresIn, owner }: {
        expiresIn: number;
        owner: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    dropOwnershipProposal: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
    claimOwnership: (funds?: Coin[]) => MsgExecuteContractEncodeObject;
    moveToProxy: ({ lpToken, proxy }: {
        lpToken: string;
        proxy: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    migrateProxy: ({ lpToken, newProxy }: {
        lpToken: string;
        newProxy: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    updateBlockedTokenslist: ({ add, remove }: {
        add?: AssetInfo[] | undefined;
        remove?: AssetInfo[] | undefined;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    deactivatePool: ({ lpToken }: {
        lpToken: string;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    deactivatePools: ({ pairTypes }: {
        pairTypes: PairType[];
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    checkpointUserBoost: ({ generators, user }: {
        generators: string[];
        user?: string | undefined;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
    callback: ({ action }: {
        action: ExecuteOnReply;
    }, funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
